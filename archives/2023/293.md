---
title: 细谈设计模式
number: '#293'
link: 'https://github.com/toFrankie/blog/issues/293'
created_at: '2023-02-26 21:10:37'
updated_at: '2024-12-04 16:16:52'
labels:
  - 尚未完结
  - JS
  - '2022'
---
![配图源自 Freepik](https://cdn.jsdelivr.net/gh/toFrankie/blog@main/images/2023/2/1677417091573.png)

终于有时间写这一系列啦...

## 一、起源

* 1977 年，建筑师 Christopher Alexander 编写了一本汇集设计模式的书，模式（Pattern）一词源自此书。
* 1987 年，Kent Beck 和 Ward Cunningham 利用 Christopher Alexander 的思想开发了设计模式（Design Pattern），并首次应用于计算机领域。
* 1989 年，Erich Gamma 在其博士毕业论文中将这种思想改写为适用于软件开发。
* 1989 ~ 1991 年期间，James Coplien 利用相同的思想致力于 C++ 开发。
* 1994 年，被称为四人帮（Gang of Four，GoF）的 Erich Gamma、Richard Helm、Ralph Johnson、John Vlissides 于 1994 年合作出版了《Design Patterns: Elements of Reusable Object-Oriented Software》一书，此书共收录了 23 种设计模式。

更多请看[维基百科](https://www.wikiwand.com/en/Software_design_pattern)。

## 二、简介

设计模式用于解决软件「设计」层面的问题，而非具体的编码实现。

> 设计模式（Design Pattern），是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性、程序的重用性。 （摘自[百度百科](https://baike.baidu.com/item/软件设计模式/2117635)）

### 三、设计原则

设计模式并不是语言规范，解决实际问题时并没有规范必须使用哪一种设计模式，不宜生搬硬套，应灵活运用。**最重要的是，一定不要为了用设计模式而用设计模式，避免设计过度，使得简单问题复杂化。因此，在用之前应思考问题本身是否需要设计模式。**

通常应遵循七大设计原则：


* 开闭原则（Open Closed Principle，OCP）
  当应用的需求改变时，在不修改软件实体的源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求。

* 里氏替换原则（Liskov Substitution Principle，LSP）
  子类可以扩展父类的功能，但不能改变父类原有的功能。

* 依赖倒置原则（Dependence Inversion Principle，DIP）
  高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。

* 单一职责原则（Single Responsibility Principle，SRP）
  其核心是控制类的粒度大小、将对象解耦、提高其内聚性。

* 接口隔离原则（Interface Segregation Principle，ISP）
  为了约束接口、降低类对接口的依赖性。

* 迪米特法则（Law of Demeter，LoD）
  如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。

* 合成复用原则（Composite Reuse Principle，CRP）
  通过将已有的对象纳入新对象中，作为新对象的成员对象来实现的，新对象可以调用已有对象的功能，从而达到复用。

根据侧重点总结归纳：

| 设计原则 | 一句话归纳 | 目的 |
| --- | --- | --- |
| 开闭原则 | 对扩展开放，对修改关闭 | 降低维护带来的新风险 |
| 依赖倒置原则 | 高层不应该依赖低层，要面向接口编程 | 更利于代码结构的升级扩展 |
| 单一职责原则 | 一个类只干一件事，实现类要单一 | 便于理解，提高代码的可读性 |
| 接口隔离原则 | 一个接口只干一件事，接口要精简单一 | 功能解耦，高聚合、低耦合 |
| 迪米特法则 | 不该知道的不要知道，一个类应该保持对其它对象最少的了解，降低耦合度 | 只和朋友交流，不和陌生人说话，减少代码臃肿 |
| 里氏替换原则 | 不要破坏继承体系，子类重写方法功能发生改变，不应该影响父类方法的含义 | 防止继承泛滥 |
| 合成复用原则 | 尽量使用组合或者聚合关系实现代码复用，少使用继承 | 降低代码耦合 |

以上这些原则的目的只有一个：降低对象之间的耦合，增加程序的可复用性、可扩展性和可维护性。

> 访问加限制，函数要节俭，依赖不允许，动态加接口，父类要抽象，扩展不更改。

### 四、分类

一个软件设计模式的格式根据作者的不同，划分和名称等都会有所不同。《Design Patterns》一书将设计模式分为三大类：创建型模式、结构型模式和行为型模式，共 23 种。

* 创建型模式
  * 工厂方法模式
  * 抽象工厂模式
  * 建造者模式
  * 原型模式
  * 单例模式
* 结构型模式
  * 适配器
  * 桥接
  * 组合
  * 装饰器
  * 外观
  * 享元
  * 代理
* 行为型模式
  * 责任链
  * 命令
  * 解释器
  * 迭代器
  * 中介
  * 备忘录
  * 观察者
  * 状态
  * 策略
  * 模板方法
  * 访问者

注意，设计模式并不是某一门编程语言的专利，它适用于 Java、C++、C#、JavaScript 等面向对象的编程语言。下文将会以 JavaScript 为例。

## 五、创建型模式

### 5.1 工厂方法模式（Factory Method Pattern）

我们常说的工厂模式就是指工厂方法模式，也是使用频率非常高的设计模式之一。

**简单工厂模式**

简单工厂模式（Simple Factory Pattern）并不属于 GoF 的 23 种设计模式之一。但它是其他工厂模式的基础。





简单工厂模式虽然简单，但存在一个很严重的问题。当系统中需要引入新产品时，由于静态工厂方法通过所传入参数的不同来创建不同的产品，这必定要修改工厂类的源代码，将违背“开闭原则”，如何实现增加新产品而不影响已有代码？




定义一个接口用于创建对象，但是让子类决定初始化哪个类。工厂方法把一个类的初始化下放到子类。

未完待续...

<!--



## References

* [JavaScript设计模式es6（23种)](https://juejin.cn/post/6844904032826294286)
* [设计模式（RUNOOB）](https://www.runoob.com/design-pattern/design-pattern-tutorial.html)
* [软件设计模式概述](http://c.biancheng.net/view/1317.html)
* [设计模式](https://segmentfault.com/u/yu_5e842f4043ba6/articles?sort=newest&page=5)
-->
