---
title: Proxy 与 Reflect
number: '#334'
link: 'https://github.com/toFrankie/blog/issues/334'
created_at: '2024-04-05 19:07:10'
updated_at: '2024-04-06 15:59:12'
labels:
  - 前端
  - JS/ES
  - '2024'
---
## 元编程

元编程（meta-programming）一般分为两类，一是在编译时生成代码，二是在运行时修改代码行为。

> Just like metadata is data about data, metaprogramming is writing programs that manipulate programs. It's a common perception that metaprograms are the programs that generate other programs. But the paradigm is even broader. All of the programs designed to read, analyze, transform, or modify themselves are examples of metaprogramming. [Metaprogramming in Python](https://developer.ibm.com/tutorials/ba-metaprogramming-python/)

> [怎么理解元编程？](https://www.zhihu.com/question/23856985)

## Proxy

### 简介

如果你问我多大，通过 `person.age` 访问得到 `20`。

```js
const person = {
 name: 'Frankie',
 age: 20,
}
```



但这届年轻人，总是说「别问，问就是 18」，那么我会创建一个替身：

```js
const substitute = new Proxy(person, {
  get(target, property) {
    if (property === 'age') {
      return 18
    }
    return target[property]
  },
})
```

这样，再问我年龄时，你问的其实是 `substitute`，此时 `substitute.age` 是 18。尽管我真实年龄 `person.age` 是 20。

在 JavaScript 中，Proxy 通常用于修改某些操作的默认行为。比如，别人访问我的年龄，讲道理应该返回真实年龄（默认行为），但由于某些原因（心情不爽），就告诉你我 18。

**Proxy 对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）。**

### 基础语法

```js
const proxy = new Proxy(target, handler)
```

- `target` - 被代理的对象（下文称为源对象）。可以是任意类型的对象，比如数组、函数、另一个代理对象等。
- `handler` - 一个含有特定方法的对象。

其中 `handler` 有以下方法：

- `handler.get()`
- `handler.set()`
- `handler.has()`
- `handler.apply()`
- `handler.construct()`
- `handler.defineProperty()`
- `handler.deleteProperty()`
- `handler.getOwnPropertyDescriptor()`
- `handler.getPrototypeOf()`
- `handler.setPrototypeOf()`
- `handler.ownKeys()`
- `handler.isExtensible()`
- `handler.preventExtensions()`

> 所有方法都是可选的。如果某个方法未定义，将会保留源对象的默认行为。


一个无操作转发代理：

```js
const person = {}
const proxy = new Proxy(person, {})

proxy.name = 'Frankie'

console.log(person.name) // 'Frankie'
```

### get/set 方法

用于拦截对象的读取、赋值。

```js
const person = {
  name: 'Frankie',
  age: 20,
}

const handler = {
  get(target, property, receiver) {
    console.log(`Getting ${property}`)
    return Reflect.get(target, property, receiver)
  },
  
  set(target, property, value, receiver) {
    console.log(`Setting ${property}`)
    return Reflect.set(target, property, value, receiver)
  },
}

const proxy = new Proxy(person, handler)
```

参数：

- `target` - 源对象。
- `property` - 被读取/赋值的属性名。
- `value` - 将被赋值的值（仅 `set` 方法）。
- `receiver` - 通常是代理实例本身。

返回值：

- `get()` 方法可返回任意值。
- `set()` 方法返回布尔值，`true` 表示属性设置成功。




未完待续...
