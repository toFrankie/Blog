---
title: 如何实现一个准确的倒计时功能
number: '#339'
link: 'https://github.com/toFrankie/blog/issues/339'
created_at: '2024-05-26 13:08:30'
updated_at: '2024-05-26 13:23:49'
labels:
  - '2024'
  - JS/ES
  - 前端
---
## 背景

倒计时是一个很常见的业务场景。只有两个要求：

- 准确性高
- 性能好

假设有示例如下：

```html
<div id="countdown">0 days, 0 hours, 0 minutes, 0 seconds</div>
```

```js
window.onload = function () {
  const startTime = Date.now()
  const endTime = startTime + 90 * 1000
  countdown(endTime)
}

function countdown(endTime) {
  // 待实现...
}

function formatTimeLeft(timeLeft) {
  const secondInMillisecond = 1000
  const minuteInMillisecond = secondInMillisecond * 60
  const hourInMillisecond = minuteInMillisecond * 60
  const dayInMillisecond = hourInMillisecond * 24

  const dayLeft = Math.floor(timeLeft / dayInMillisecond)
  const hourLeft = Math.floor((timeLeft % dayInMillisecond) / hourInMillisecond)
  const minuteLeft = Math.floor((timeLeft % hourInMillisecond) / minuteInMillisecond)
  const secondLeft = Math.floor((timeLeft % minuteInMillisecond) / secondInMillisecond)

  const html = `${dayLeft} days, ${hourLeft} hours, ${minuteLeft} minutes, ${secondLeft} seconds`
  document.getElementById('countdown').innerHTML = html
}
```

## 简单实现

思路很简单，每秒更新一次 DOM 就行，是吧。

此处使用浏览器提供的 setTimeout 或 setInterval，比如：

```js
function countdown(endTime) {
  const timer = setInterval(() => {
    const now = Date.now()
    const timeLeft = endTime - now

    if (timeLeft <= 0) {
      clearInterval(timer)
      formatTimeLeft(0)
      return
    }

    formatTimeLeft(timeLeft)
  }, 1000)

  formatTimeLeft(endTime - Date.now()) // initialize the timer
}
```

> 浏览器执行顺序：同步任务 → 微任务 → 页面渲染 → 下一个宏任务 → 再下一个宏任务...

注意，setTimeout 或 setInterval 实际是在指定时间后将其加入到异步任务队列（它属于宏任务），并不是指定时间后马上执行。它还得排队，也就是等主线程空闲了之后，这个宏任务才会被执行。

> 从宏任务队列、微任务队列取出任务时，遵循「先进先出」原则。

所以，这个方案的缺点很明显。


未完待续...



