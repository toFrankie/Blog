---
title: 开发一个简单的 Chrome Extension 程序
number: '#340'
link: 'https://github.com/toFrankie/blog/issues/340'
created_at: '2024-06-16 14:32:09'
updated_at: '2024-06-16 19:26:16'
labels:
  - 生活随笔
  - 前端
  - '2024'
---
> 在此作一个开发记录，第一次开发 Chrome Extension 的同学也可以看看。

## 背景

我现在使用 [GitHub Blogger](https://github.com/toFrankie/github-blogger) 作为个人博客工具，在翻阅文章时，有个体验痛点：无法快速定位到某个章节。

比如，这篇[文章](https://github.com/toFrankie/blog/issues/317)涉及的二级、三级标题多达 25+，篇幅也很长。

<details><summary>展开看看：</summary>

- 开始之前
- 管理窗口
- 切换面板
- 切换侧栏
- 搜索与替换
    - 搜索内容
    - 替换内容
    - 搜索文件
- 编辑区
    - 移动光标
    - 选择文本
    - 移动行
    - 插入行
    - 操作行
    - 删除
    - 注释
    - 格式化
    - 折叠与展开代码
    - 保存
    - 撤销与恢复
- 命令面板
    - 常用命令
    - 配置命令
    - 查看插件命令
- 高阶用法
    - 场景一
    - 场景二
- References

</details>

目前 GitHub 只有仓库 Markdown 文件支持目录能力，但是 Issue 还不支持，所以开发一个 Chrome 扩展程序来解决。

> [github-issue-toc](https://github.com/toFrankie/github-issue-toc)

* 支持 h1 ~ h6 标题。
* 支持粘性布局，滚动时始终在可视区域内。
* 风格与 GitHub 契合，支持深色模式。

![image.png](https://cdn.jsdelivr.net/gh/toFrankie/blog@main/images/2024/6/1718520988032.png)

## 开始之前

项目没必要一步一步去搭，选择社区流行方案即可，我选 [Plasmo](https://www.plasmo.com/)，开发体验还不错。目录样式参考了 [Github](https://github.blog/changelog/2021-04-13-table-of-contents-support-in-markdown-files/)、[ByteMD](https://github.com/bytedance/bytemd)。


一些基础概念：

* [一篇文章教你顺利入门和开发 chrome 扩展程序（插件）](https://github.com/pekonchan/Blog/issues/8)
* [Chrome 浏览器插件从 Manifest V2 升级到 V3 版本所需要修改的点](https://segmentfault.com/a/1190000044555740)
* [Manifest V3 migration checklist ](https://developer.chrome.com/docs/extensions/develop/migrate/checklist)
* [Chrome Extensions](https://developer.chrome.com/docs/extensions)
* [Plasmo Documentation](https://docs.plasmo.com/)

> 第一篇作者总结得挺好，但里面一些东西在 Manifest V3 发生了变化，可以看看第二篇文章。

## 基础概念

* [manifest.json](https://developer.chrome.com/docs/extensions/reference/manifest?hl=zh-cn)（清单文件）
* [Actions](https://developer.chrome.com/docs/extensions/develop/ui?hl=zh-cn#actions)（动作）
* [Content Scripts](https://developer.chrome.com/docs/extensions/develop/concepts/content-scripts?hl=zh-cn)（内容脚本）
* [Extension Service Worker](https://developer.chrome.com/docs/extensions/develop/concepts/service-workers?hl=zh-cn)（原 V2 的 Background Scripts）

清单文件是每个扩展程序必须的，它会列出扩展程序的结构和行为等信息。

Actions 是点击扩展程序图标时发生的动作，可以是打开一个弹出式窗口、打开侧边栏面板、右键菜单等等。

内容脚本主要用于修改网页内容。

Extension Service Worker 是运行在浏览器里的后台脚本。

它们之间可以相互传递消息，详见[消息传递](https://developer.chrome.com/docs/extensions/develop/concepts/messaging?hl=zh-cn)。

## 开始

创建项目：

```shell
$ pnpm create plasmo --with-src --entry=contents/inline,popup,background
```

> 似乎 [`--entry`](https://docs.plasmo.com/framework/workflows/new#with-specific-entry-files) 指定入口目录有点问题，我只用到弹出式窗口、内容脚本以及 Service Worker，但生成的模板包括了 `newtab`，需手动删掉。

### Content Scripts

前面提到，内容脚本是用来修改网页内容的，但它跟网页的 JavaScript 环境是隔离的。

#### 分类

在 Plasmo 里，内容脚本分为两类：

* content.ts
* content.tsx

`.ts` 表示没有 UI 界面的纯脚本，后者则是带 UI 的组件，所以它要默认导出 Component。

> 此处 `.tsx` 是以 React 为例，其他框架则是 `.vue`、`.svelte` 扩展名。

> 由于 Plasmo 将所有文件视为模块，如果你的纯内容脚本没有任何导出，则必要要加上 `export {}`。

> 如果有多个内容脚本，则用 `contents` 目录，比如 `contents/foo.tsx`、`contents/bar.tsx`。


#### 导出配置

主要用于定义脚本作用的网页地址、执行时机等。

```tsx
// tos.tsx
import type { PlasmoCSConfig } from 'plasmo'

export const config: PlasmoCSConfig = {
  matches: ['https://github.com/*'],
  run_at: 'document_end'
}
```

> 其中配置项详见 [Inject with static declarations](https://developer.chrome.com/docs/extensions/develop/concepts/content-scripts#static-declarative)。

> 如果你的脚本要修改网页的 `window` 对象，要指定 `world` 配置项为 `'MAIN'`。

#### 指定插入锚点

也就是我们的 UI 脚本要挂载到网页的哪个地方。

```tsx
// tos.tsx
import type { PlasmoCSConfig, PlasmoGetInlineAnchor } from 'plasmo'

export const config: PlasmoCSConfig = {
  matches: ['https://github.com/*'],
  run_at: 'document_end'
}

// 🆕
export const getInlineAnchor: PlasmoGetInlineAnchor = async () => ({
  element: document.querySelector('#partial-discussion-sidebar'),
  insertPosition: 'afterend'
})

export default function Toc() {
  return <div className="toc">Toc 组件</div>
}
```

> 如果需要挂载多个，导出 `getInlineAnchorList`，详见 [Inline Anchor](https://docs.plasmo.com/framework/content-scripts-ui/life-cycle#inline)。


![](https://cdn.jsdelivr.net/gh/toFrankie/blog@main/images/2024/6/1718531425354.png)

#### 引入样式文件

假设引入 `toc.tsx` 同级目录下的 `toc.css` 文件。

```css
/* toc.css */
.toc {
  color: #0969da;
}
```

```tsx
// tos.tsx
import type { PlasmoCSConfig, PlasmoGetStyle } from 'plasmo'
import styleText from 'data-text:./toc.css'

// 🆕
export const config: PlasmoCSConfig = {
  matches: ['https://github.com/*'],
  css: ['./toc.css'],
  run_at: 'document_end'
}

export const getStyle: PlasmoGetStyle = () => {
  const style = document.createElement('style')
  style.textContent = styleText
  return style
}

export default function Toc() {
  return <div className="toc">Toc 组件</div>
}
```

导出一个 `getStyle` 方法，读取文件的内容，然后往网页插入一个 `<style>` 标签。

> 对于 `data-text:./toc.css` 的写法，详见 [Import Resolution](https://docs.plasmo.com/framework/import#data-text)。

![](https://cdn.jsdelivr.net/gh/toFrankie/blog@main/images/2024/6/1718532184534.png)

#### 自定义 Root Container

默认情况下，Plasmo 会创建 Shadow DOM，再挂载到页面，这样做的好处是与外部隔离，如上图所示。

有时，我们希望可以用原网页的样式，比如 CSS 变量等。

这样的话，需要导出一个 `getRootContainer` 方法。

```tsx
// tos.tsx
import type { PlasmoCSConfig, PlasmoGetStyle, PlasmoGetInlineAnchor } from 'plasmo'
import styleText from 'data-text:./toc.css'

export const config: PlasmoCSConfig = {
  matches: ['https://github.com/*'],
  css: ['./toc.css'],
  run_at: 'document_end'
}

export const getStyle: PlasmoGetStyle = () => {
  const style = document.createElement('style')
  style.textContent = styleText
  return style
}

// 🆕 移除掉
// export const getInlineAnchor: PlasmoGetInlineAnchor = async () => ({
//   element: document.querySelector('#partial-discussion-sidebar'),
//   insertPosition: 'afterend'
// })

// 🆕
export const getRootContainer = () => {
  return new Promise(resolve => {
    const timer = setInterval(() => {
      const rootContainer = document.querySelector('#plasmo-toc')
      if (rootContainer) {
        clearInterval(timer)
        resolve(rootContainer)
        return
      }

      const rootContainerParent = document.querySelector('.Layout-sidebar')
      if (rootContainerParent) {
        clearInterval(timer)

        const rootContainer = document.createElement('div')
        rootContainer.id = 'plasmo-toc'
        rootContainerParent.appendChild(rootContainer)

        resolve(rootContainer)
      }
    }, 200)
  })
}

export default function Toc() {
  return <div className="toc">Toc 组件</div>
}
```

> 这里用到 `setInterval()` 是为了确保挂载点的父级已加载完毕。

以上示例，我在 `.Layout-sidebar` 下添加了 `#plasmo-toc` 元素，并将 Toc 组件挂载到上面，以实现上述 `getInlineAnchor` 的 `insertPosition: 'afterend'` 的效果。原因是 ReactDOM 的 `createRoot()` 会覆盖挂载元素的内容，它会吞掉 `.Layout-sidebar` 的所有内容，这不是我想要的。

#### 自定义 render

前面 [`run_at`](https://developer.chrome.com/docs/extensions/reference/manifest/content-scripts?hl=zh-cn#world-timings) 指定为 `document_end`，还有其他值：

* `document_start`：在 css 中的任何文件之后、构建任何其他 DOM 或运行任何其他脚本之前注入脚本。

* `document_end`：在 DOM 完成之后，在图片和框架等子资源加载之前立即注入脚本。


* `document_idle`：浏览器会选择一个时间，在 `document_end` 之间以及 `window.onload` 事件触发后立即注入脚本。注入的确切时刻取决于文档的复杂程度和加载用时，并针对网页加载速度进行了优化。在 `document_idle` 运行的内容脚本不需要监听 `window.onload` 事件；它们一定会在 DOM 完成后运行。如果脚本确实需要在 `window.onload` 之后运行，该扩展程序可以使用 `document.readyState` 属性检查 `onload` 是否已触发。这是默认值。


以 TOC 组件为例，当进入页面后，页面加载完毕，然后生成了目录。如果后续 Markdown 内容通过 Ajax 方式更新了，那目录有可能跟最新内容对不上了。这里有两种解决方法：

* 一是，在 TOC 组件内监听内容变化，进而触发组件更新。
* 二是，当内容更新时，先卸载旧的 TOC 组件，再挂载新的 TOC 组件。

按需选择。在 GitHub Issue TOC 的场景，要用第二种方式。原因是，在 GitHub 的非 Issue 页面跳转到 Issue 页面时，应该是使用了 `history.pushState()` 方式，它不会重新加载页面，导致目录就不会生成了。这种情况靠 `document_end` 是无法解决的。

```tsx
// tos.tsx
import type { PlasmoCSConfig, PlasmoGetStyle, PlasmoCSUIJSXContainer, PlasmoRender } from 'plasmo'
import styleText from 'data-text:./toc.css'

export const config: PlasmoCSConfig = {
  matches: ['https://github.com/*'],
  css: ['./toc.css'],
  run_at: 'document_end'
}

export const getStyle: PlasmoGetStyle = () => {
  const style = document.createElement('style')
  style.textContent = styleText
  return style
}

export const getRootContainer = () => {
  return new Promise(resolve => {
    const timer = setInterval(() => {
      const rootContainer = document.querySelector('#plasmo-toc')
      if (rootContainer) {
        clearInterval(timer)
        resolve(rootContainer)
        return
      }

      const rootContainerParent = document.querySelector('.Layout-sidebar')
      if (rootContainerParent) {
        clearInterval(timer)

        const rootContainer = document.createElement('div')
        rootContainer.id = 'plasmo-toc'
        rootContainerParent.appendChild(rootContainer)

        resolve(rootContainer)
      }
    }, 200)
  })
}

// 🆕
export const render: PlasmoRender<PlasmoCSUIJSXContainer> = async ({ createRootContainer }) => {
  const url = document.location.href
  if (!isGitHubIssuePage(url)) return

  const rootContainer = await createRootContainer()
  const root = createRoot(rootContainer)
  window.__plasmoTocRoot = root
  root.render(<Toc />)
}

export default function Toc() {
  return <div className="toc">Toc 组件</div>
}
```

具体逻辑，按需调整。由于重新挂载页面时，要先将旧的 React App 卸载，所以这里记录了`window.__plasmoTocRoot = root` 供下次挂载用。比如：

```tsx
async function recreateRoot() {
  const rootContainer = await getRootContainer()

  if (window.__plasmoTocRoot) {
    window.__plasmoTocRoot.unmount()
  }

  const root = createRoot(rootContainer as Element)
  window.__plasmoTocRoot = root
  root.render(<Toc />)

  onIssueUpdate()
}
```
