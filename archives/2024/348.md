---
title: 通过两个例子再探 Event Loop
number: '#348'
link: 'https://github.com/toFrankie/blog/issues/348'
created_at: '2024-08-11 16:42:16'
updated_at: '2024-08-17 23:51:15'
labels:
  - 前端
  - JS
  - '2024'
---

## 提问

假设有示例：

```html
<article>
  <h1>蒹葭</h1>
  <p>蒹葭苍苍，白露为霜。所谓伊人，在水一方。溯洄从之，道阻且长。溯游从之，宛在水中央。</p>
  <p>蒹葭萋萋，白露未晞。所谓伊人，在水之湄。溯洄从之，道阻且跻。溯游从之，宛在水中坻。</p>
  <p>蒹葭采采，白露未已。所谓伊人，在水之涘。溯洄从之，道阻且右。溯游从之，宛在水中沚。</p>
  <p></p>
</article>

<button onclick="whileLoop()">点我</button>
<button onclick="timerLoop()">点我</button>

<script>
  function whileLoop() {
    while (true) {}
  }

  function timerLoop() {
    setTimeout(timerLoop, 0)
  }
</script>
```

请问上述两个点击事件会导致页面卡死吗？

## 从简单说起

Event Loop 是浏览器最重要的机制，它确保了页面可以有序执行。

用伪代码表示：

```js
while (true) {
  task = taskQueue.pop()
  execute(task)
}
```

没错，它是一个无限循环的。它 7 × 24 随时待命，只要任务队列有任务，它就不断地从队列中取出一个任务执行完，接着下一个，直到执行完队列中所有任务。

### 什么是任务？

假设有页面：

```html
<div id="count">0</div>
<button id="btn">+1</button>

<script>
  let count = 0

  document.getElementById('btn').addEventListener('click', () => {
    document.getElementById('count').textContent = ++count
  })
</script>
```

上述示例，我们给按钮注册了一个点击监听事件。

用户每点击按钮一次，就会产生一个任务，并添加到任务队列。

除此之外，与用户发生交互而产生的所有事件（比如双击、文本选择、页面滚动、键盘输入等）、setTimeout、setInterval、I/O 操作等都属于任务。

> 任务里也可以产生新任务。

### 什么是任务队列？

队列是一种先进先出（first in, first out）的机制。

也就是说，更早放入任务队列的任务会优先执行，排在后面的则必须等待前面的任务执行完之后才会开始执行。

### 页面渲染

实际情况还有更复杂一些。

本质上，网页就是给人看的，与人交互的，所以用户体验非常重要。假设任务队列有源源不断的任务产生，如果 Event Loop 只会一直循环执行队列里的任务，而不去更新页面，用户体验是非常糟糕的。

因此，当一个任务执行完，“**可能**”会先更新 DOM，完了之后才执行下一个任务。

浏览器是非常聪明的，没必要的工作它不会做。以 60Hz 刷新率的显示器为例，每秒刷新 60 次，每 16.67ms 刷新一次。满足这个刷新频率的，那么显示效果算是流畅的，否则就会有卡顿感（随着更高刷新率的显示设备越来越多，对比之下 60Hz 刷新率也不算很流畅，当然这是题外话）。假设一个任务只耗时 3 ~ 5ms，远没到达 16ms，此时更新 DOM 是没有意义的，这样的话浏览器就不会更新 DOM，而是接着执行下一个任务。因此，前面才会提到“可能”二字。

> 比如 React 16 的调度机制，可以控制中断当前执行中的任务，执行完优先级更高的任务（比如更新 DOM），完了再继续此前未完成的任务，以解决某些场景下页面卡顿的问题。



