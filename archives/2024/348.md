---
title: 通过两个例子再探 Event Loop
number: '#348'
link: 'https://github.com/toFrankie/blog/issues/348'
created_at: '2024-08-11 16:42:16'
updated_at: '2024-08-18 18:37:50'
labels:
  - 前端
  - JS
  - '2024'
---


![配图源自 Freepik](https://cdn.jsdelivr.net/gh/toFrankie/blog@main/images/2024/8/1723914079530.jpg)

## 提问

假设有示例：

```html
<article>
  <h1>蒹葭</h1>
  <p>蒹葭苍苍，白露为霜。所谓伊人，在水一方。溯洄从之，道阻且长。溯游从之，宛在水中央。</p>
  <p>蒹葭萋萋，白露未晞。所谓伊人，在水之湄。溯洄从之，道阻且跻。溯游从之，宛在水中坻。</p>
  <p>蒹葭采采，白露未已。所谓伊人，在水之涘。溯洄从之，道阻且右。溯游从之，宛在水中沚。</p>
  <p></p>
</article>

<button onclick="whileLoop()">点我</button>
<button onclick="timerLoop()">点我</button>

<script>
  function whileLoop() {
    while (true) {}
  }

  function timerLoop() {
    setTimeout(timerLoop, 0)
  }
</script>
```

请问上述两个点击事件会导致页面卡死吗？

## 从简单说起

Event Loop 是浏览器最重要的机制，它确保了页面可以有序执行。

用伪代码表示：

```js
while (true) {
  task = taskQueue.pop()
  execute(task)
}
```

没错，它是无限循环的，7 × 24h 随时待命，只要任务队列有任务，它就不断地从队列中取出一个任务执行完，接着下一个，直到执行完队列中所有任务。

### 什么是任务？

假设有页面：

```html
<div id="count">0</div>
<button id="btn">+1</button>

<script>
  let count = 0

  document.getElementById('btn').addEventListener('click', () => {
    document.getElementById('count').textContent = ++count
  })
</script>
```

上述示例，我们给按钮注册了一个点击监听事件。

用户每点击按钮一次，就会产生一个任务，并添加到任务队列。

除此之外，与用户发生交互而产生的所有事件回调（比如双击、文本选择、页面滚动、键盘输入等）、setTimeout、setInterval、\<script> 块、I/O 操作等都属于任务。

> 任务里也可以产生新任务。

### 什么是任务队列？

队列是一种先进先出（first in, first out）的机制。

也就是说，更早放入任务队列的任务会优先执行，排在后面的则必须等待前面的任务执行完之后才会开始执行。

### 页面渲染

实际情况还有更复杂一些。

本质上，网页就是给人看的，与人交互的，所以用户体验非常重要。假设任务队列有源源不断的任务产生，如果 Event Loop 只会一直循环执行队列里的任务，而不去更新页面，用户体验是非常糟糕的。

因此，当一个任务执行完，“**可能**”会先更新 DOM，完了之后才执行下一个任务。

> 至此，可以再思考下文章开头的提问。

浏览器是非常聪明的，没必要的工作它不会做。以 60Hz 刷新率的显示器为例，每秒刷新 60 次，约 16.7ms 刷新一次。满足这个刷新频率的，那么显示效果算是流畅的，否则就会有卡顿感（随着更高刷新率的显示设备越来越多，对比之下 60Hz 刷新率也不算很流畅，当然这是题外话）。假设一个任务只耗时 3 ~ 5ms，远没到达 16ms，此时更新 DOM 是没有意义的，这样的话浏览器就不会更新 DOM，而是接着执行下一个任务。因此，前面才会提到“可能”二字。

> 规范不强制要求使用任何特定模型来选择渲染机会。但例如，如果浏览器尝试实现 60Hz 刷新率，则渲染机会最多每 60 秒出现一次（约 16.7ms）。如果浏览器发现 [navigable](https://html.spec.whatwg.org/multipage/document-sequences.html#navigables) 无法维持此速率，则该 navigable 可能会下降到更可持续的每秒 30 个渲染机会，而不是偶尔丢帧。类似地，如果 navigable 不可见，用户代理可能会决定将该页面降低到每秒 4 个渲染机会，甚至更少。

> 比如 React 16 的调度机制，可以控制中断当前执行中的任务，执行完优先级更高的任务（比如更新 DOM），完了再继续此前未完成的任务，以解决某些场景下页面卡顿的问题。

Event Loop 现在是这样的：

```js
while (true) {
  task = taskQueue.pop()
  execute(task)
  
  if (isRepaintTime()) repaint()
}
```

## 开始复杂起来了

实际远没那么简单。从[规范](https://html.spec.whatwg.org/multipage/webappapis.html#event-loops)可以看到：

> An event loop has one or more task queues.

> Task queues are [sets](https://infra.spec.whatwg.org/#ordered-set), not [queues](https://infra.spec.whatwg.org/#queue), because the [event loop processing model](https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model) grabs the first [runnable task](https://html.spec.whatwg.org/multipage/webappapis.html#concept-task-runnable) from the chosen queue, instead of [dequeuing](https://infra.spec.whatwg.org/#queue-dequeue) the first task.

> The [microtask queue](https://html.spec.whatwg.org/multipage/webappapis.html#microtask-queue) is not a task queue.

什么？

- Event Loop 有一个或多个任务队列。
- 任务队列是集合，不是队列。
- 执行时，事件循环处理模型从所选队列中获取第一个可运行的任务，而不是使第一个任务出队。

完了，推翻了前面的结论，啪啪打脸 🤦

其实不一定，如果你只想了解 Event Loop 主要执行顺序，不深入浏览器究竟维护了多少个任务队列、浏览器如何决定下一任务，那么简单地理解为这样也是没有问题的：Event Loop 只有一个任务队列，队列仍是按照先进先出的顺序执行，只不过它实际由浏览器决定，将其按序放入我们所理解的“任务队列”里面而已。

> 想了解更多请看 [Processing model](https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model)。

Event Loop 现在是这样的：

```js
while (true) {
  queue = getNextQueue()
  task = queue.getFirstRunnableTask()
  execute(task)
  
  if (isRepaintTime()) repaint()
}
```

## 还没完，还有微任务

还没完，还没完，还有微任务队列。

从[规范](https://html.spec.whatwg.org/multipage/webappapis.html#microtask-queue)可以看到：

> Each event loop has a [microtask queue](https://html.spec.whatwg.org/multipage/webappapis.html#microtask-queue), which is a [queue](https://infra.spec.whatwg.org/#queue) of microtasks, initially empty.

> A [microtask](https://html.spec.whatwg.org/multipage/webappapis.html#microtask) is a colloquial way of referring to a [task](https://html.spec.whatwg.org/multipage/webappapis.html#concept-task) that was created via the [queue a microtask](https://html.spec.whatwg.org/multipage/webappapis.html#queue-a-microtask) algorithm.

> The microtask queue is not a [task queue](https://html.spec.whatwg.org/multipage/webappapis.html#task-queue).

好，我们重新捋一下：

- 一个 Event Loop 有一个或多个 task queue。
- 一个 Event Loop 有且仅有一个 microtask queue。
- task 是一个由特定属性的对象（规范中称为 [struct](https://html.spec.whatwg.org/multipage/webappapis.html#concept-task)）。
- microtask 只是一种通俗的说法，它是通过[特定算法](https://html.spec.whatwg.org/multipage/webappapis.html#queue-a-microtask)创建的 task。
- task queue 是一组 task 的[集合](https://infra.spec.whatwg.org/#ordered-set)，并不是[队列](https://infra.spec.whatwg.org/#queue)。
- microtask 是队列，出队时按先进先出的顺序。
- microtask queue 不是 task queue，前者是队列，后者是集合。

为便于区分理解，本文暂且将以下规范术语口语化（**但注意这种说法不一定准确**）。

* task：（宏）任务
* task queue：（宏）任务队列
* microtask：微任务
* microtask queue：微任务队列

### 何时执行？

从规范（[Processing model](https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model)）可知，只有 Event Loop 存在，就必须不断执行以下步骤：

1. 从（宏）任务队列取出一个 task
2. 执行该 task
3. 执行微任务检查点（[microtask checkpoint](https://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpoint)）
    1. 如果检查点标志为真（初始值为 false），则返回（跳出微任务执行）。
    2. 将检查点标志设为 true
    3. 如果当前 Event Loop 里的微任务队列不为空，将一直循环直至微队列为空：
        1. 在微任务队列里取出的第一个微任务（此处的出队，就是先进先出的出队）
        2. 执行该 microtask
    4. 将检查点标志设为 false
4. 重复上述步骤

> 以上为简化后的步骤，为了更简单地介绍 task 和 microtask 执行顺序。

请注意，如果在执行微队列任务的过程中，产生更多新的微任务，它们将会在下一个（宏）任务之前执行。

至此，文章开头的提问之一就有答案。

Event Loop 的不断循环执行是在主线程完成的，而且是单线程的，那么它就会一直重复上述 3.iii 的过程，它将无休止下去，自然无法更新 DOM、执行后面的（宏）任务，因此页面就“卡死”了。

### 有哪些微任务？

在 JavaScript 里会产生微任务的大概有：

- queueMicrotask（Window 或 Web Worker）
- Promise 回调
- MutationObserver 回调
- Object.observe（Deprecated）

Event Loop 现在是这样的：

```js
while (true) {
  queue = getNextQueue()
  task = queue.getFirstRunnableTask()
  execute(task)
  
  while (microtaskQueue.hasTask() {
    microtask = microtaskQueue.pop()
    excute(microtask)
  }
  
  if (isRepaintTime()) repaint()
}
```

## 噢，还有 requestAnimationFrame

是的，还没完，还有一个 requestAnimationFrame，其回调函数会在页面重绘之前调用。

当浏览器检测到该更新屏幕了，会执行以下流程：

1. 执行 requestAnimationFrame 回调
2. 合成：计算样式，将 DOM Tree 和 CSSOM Tree 合成一个 Render Tree（Attachment）
3. 重排：以确定每个节点所占空间、所在位置等（Layout）
4. 重绘：以设置颜色等（Paint）

> 实际情况，Edge 和 Safari 浏览器将 requestAnimationFrame 回调放到 Paint 后面执行，这是非标准做法。如果回调中涉及样式，也就是说用户要在下一帧才能看到变化。

> 是否已修复，待验证。

好了，现在 Event Loop 里还有一个 animation frame callbacks，它是一个映射（[ordered map](https://infra.spec.whatwg.org/#ordered-map)）。将它简单理解为“队列”也不是不行，因为根据 [run the animation frame callbacks](https://html.spec.whatwg.org/multipage/imagebitmap-and-animations.html#run-the-animation-frame-callbacks) 可以看到，也是从第一个开始遍历执行。

还要注意，如果遍历执行 callbacks 的过程中产生新的 callback，它们会放到下一次 Loop 执行，这点跟微任务是不一样的。

Event Loop 现在是这样的：

```js
while (true) {
  queue = getNextQueue()
  task = queue.getFirstRunnableTask()
  execute(task)
  
  while (microtaskQueue.hasTask() {
    microtask = microtaskQueue.pop()
    excute(microtask)
  }
  
  if (isRepaintTime()) {
    callbacks = animationFrameCallbacks.splice(0, animationFrameCallbacks.length)
    for (callback of callbacks) {
      execute(callback)
    }
    
    repaint()
  }
}
```

### 思考题

你有没有担心过，以下代码会“闪一下”？

```js
document.body.appendChild(someElement)
someElement.style.display = 'none'
```

再比如：

```js
<div id="box" style="width: 100px; height: 100px; background: red"></div>
<button id="btn">Click me</button>

<script>
  const btn = document.getElementById('btn')
  const box = document.getElementById('box')

  btn.addEventListener('click', () => {
    box.style.display = 'none'
    box.style.display = 'block'
    box.style.display = 'none'
    box.style.display = 'block'
    box.style.display = 'none'
    box.style.display = 'block'
    // ...
  })
</script>
```

[CodePen](https://codepen.io/tofrankie/pen/vYqdGKK)

请问点击按钮红色块会闪烁吗？

> 答案：不会。

原因：上述点击事件产生一个 task（事件回调），只有执行完 task 里面的代码，才有可能进入渲染流程。也就是说渲染之前，实际只有最后一行的样式设置是起作用的，不管你中间设了多少遍，浏览器只关心最后的样式如何。

## References

- [Event loops spec](https://html.spec.whatwg.org/multipage/webappapis.html#event-loops)
