---
title: 通过两个例子再探 Event Loop
number: '#348'
link: 'https://github.com/toFrankie/blog/issues/348'
created_at: '2024-08-11 16:42:16'
updated_at: '2024-08-18 00:57:39'
labels:
  - 前端
  - JS
  - '2024'
---

## 提问

假设有示例：

```html
<article>
  <h1>蒹葭</h1>
  <p>蒹葭苍苍，白露为霜。所谓伊人，在水一方。溯洄从之，道阻且长。溯游从之，宛在水中央。</p>
  <p>蒹葭萋萋，白露未晞。所谓伊人，在水之湄。溯洄从之，道阻且跻。溯游从之，宛在水中坻。</p>
  <p>蒹葭采采，白露未已。所谓伊人，在水之涘。溯洄从之，道阻且右。溯游从之，宛在水中沚。</p>
  <p></p>
</article>

<button onclick="whileLoop()">点我</button>
<button onclick="timerLoop()">点我</button>

<script>
  function whileLoop() {
    while (true) {}
  }

  function timerLoop() {
    setTimeout(timerLoop, 0)
  }
</script>
```

请问上述两个点击事件会导致页面卡死吗？

## 从简单说起

Event Loop 是浏览器最重要的机制，它确保了页面可以有序执行。

用伪代码表示：

```js
while (true) {
  task = taskQueue.pop()
  execute(task)
}
```

没错，它是无限循环的，7 × 24 随时待命，只要任务队列有任务，它就不断地从队列中取出一个任务执行完，接着下一个，直到执行完队列中所有任务。

### 什么是任务？

假设有页面：

```html
<div id="count">0</div>
<button id="btn">+1</button>

<script>
  let count = 0

  document.getElementById('btn').addEventListener('click', () => {
    document.getElementById('count').textContent = ++count
  })
</script>
```

上述示例，我们给按钮注册了一个点击监听事件。

用户每点击按钮一次，就会产生一个任务，并添加到任务队列。

除此之外，与用户发生交互而产生的所有事件（比如双击、文本选择、页面滚动、键盘输入等）、setTimeout、setInterval、I/O 操作等都属于任务。

> 任务里也可以产生新任务。

### 什么是任务队列？

队列是一种先进先出（first in, first out）的机制。

也就是说，更早放入任务队列的任务会优先执行，排在后面的则必须等待前面的任务执行完之后才会开始执行。

### 页面渲染

实际情况还有更复杂一些。

本质上，网页就是给人看的，与人交互的，所以用户体验非常重要。假设任务队列有源源不断的任务产生，如果 Event Loop 只会一直循环执行队列里的任务，而不去更新页面，用户体验是非常糟糕的。

因此，当一个任务执行完，“**可能**”会先更新 DOM，完了之后才执行下一个任务。

浏览器是非常聪明的，没必要的工作它不会做。以 60Hz 刷新率的显示器为例，每秒刷新 60 次，约 16.7ms 刷新一次。满足这个刷新频率的，那么显示效果算是流畅的，否则就会有卡顿感（随着更高刷新率的显示设备越来越多，对比之下 60Hz 刷新率也不算很流畅，当然这是题外话）。假设一个任务只耗时 3 ~ 5ms，远没到达 16ms，此时更新 DOM 是没有意义的，这样的话浏览器就不会更新 DOM，而是接着执行下一个任务。因此，前面才会提到“可能”二字。

> 规范不强制要求使用任何特定模型来选择渲染机会。但例如，如果浏览器尝试实现 60Hz 刷新率，则渲染机会最多每 60 秒出现一次（约 16.7ms）。如果浏览器发现 [navigable](https://html.spec.whatwg.org/multipage/document-sequences.html#navigables) 无法维持此速率，则该 navigable 可能会下降到更可持续的每秒 30 个渲染机会，而不是偶尔丢帧。类似地，如果 navigable 不可见，用户代理可能会决定将该页面降低到每秒 4 个渲染机会，甚至更少。

> 比如 React 16 的调度机制，可以控制中断当前执行中的任务，执行完优先级更高的任务（比如更新 DOM），完了再继续此前未完成的任务，以解决某些场景下页面卡顿的问题。

Event Loop 现在是这样的：

```js
while (true) {
  task = taskQueue.pop()
  execute(task)
  
  if (isRepaintTime()) repaint()
}
```

## 开始复杂起来了

实际远没那么简单。从[规范](https://html.spec.whatwg.org/multipage/webappapis.html#event-loops)可以看到：

> An event loop has one or more task queues.

> Task queues are [sets](https://infra.spec.whatwg.org/#ordered-set), not [queues](https://infra.spec.whatwg.org/#queue), because the [event loop processing model](https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model) grabs the first [runnable task](https://html.spec.whatwg.org/multipage/webappapis.html#concept-task-runnable) from the chosen queue, instead of [dequeuing](https://infra.spec.whatwg.org/#queue-dequeue) the first task.

> The [microtask queue](https://html.spec.whatwg.org/multipage/webappapis.html#microtask-queue) is not a task queue.

什么？

- Event Loop 有一个或多个任务队列。
- 任务队列是集合，不是队列。
- 执行时，事件循环处理模型从所选队列中获取第一个可运行的任务，而不是使第一个任务出队。

完了，推翻了前面的结论，啪啪打脸 🤦

其实不一定，如果我们只是想要理解 Event Loop 主要执行顺序的话，不深入了解浏览器究竟维护了多少个（种）任务队列、浏览器是如何决定下一任务的，那么可以简单的理解成：Event Loop 有一个任务队列，队列是按照先进先出的顺序执行，只不过它实际由浏览器决定，将其选好的任务按序放到我们理解的任务队列里而已（[了解更多](https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model)）。

Event Loop 现在是这样的：

```js
while (true) {
  queue = getNextQueue()
  task = queue.getFirstTask()
  execute(task)
  
  if (isRepaintTime()) repaint()
}
```


## References

- [Event loops spec](https://html.spec.whatwg.org/multipage/webappapis.html#event-loops)
